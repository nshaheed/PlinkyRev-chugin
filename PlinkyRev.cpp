//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "PlinkyRev", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (PlinkyRev.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a PlinkyRev-test.ck boilerplate ChucK program
//      to help test your chugin (see PlinkyRev-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"

// general includes
#include <iostream>
#include <stdlib.h>
#include <algorithm>
#include <limits>
#include <cstdint>
#include <math.h>
#include <array>


/**********************/
/* Chugin Version     */
/**********************/
#define VERSION "1.0.0"

/**********************/
/* from core.h        */
/**********************/

// struct int24{
//     unsigned int data : 24;
// };

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint64_t u32;
#ifndef __cplusplus
typedef char bool;
#define true 1
#define false 0
#endif

/**********************/
/* from lfo.h         */
/**********************/
typedef struct lfo {
	float r, i, a;
} lfo;
#define LFOINIT(f) (lfo {1.f, 0.f, (f) + (f)})
void lfo_setfreq(lfo *l, float f) {
	l->a = f + f;
}
float lfo_next(lfo *l) {
	l->r -= l->a * l->i;
	l->i += l->a * l->r;
	return l->r;
}

/**********************/
/* from audiointrin.h */
/**********************/

#define RVMASK 16383 // define len of reverb
#define FLOAT2FIXED(x,bits) ((int)((x)*(1<<(bits))))
#define STEREOUNPACK(lr) int lr##l=(s16)lr, lr##r=(s16)(lr>>16);

u32 STEREOPACK(s16 l, s16 r) {
#ifdef CORTEX
	int32_t out;
	asm ("pkhbt %0, %1, %2, lsl #16" : "=r" (out) : "r" (l), "r" (r));
	return out;
#else
	return ((u16)l)+(((u16)r)<<16);
#endif
}

u32 STEREOADDAVERAGE(u32 a, u32 b) {
#ifdef CORTEX
	int32_t out;
	asm ("shadd16 %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
	return out;
#else
	STEREOUNPACK(a);
	STEREOUNPACK(b);
	return STEREOPACK((al+bl)>>1,(ar+br)>>1);
#endif
}

s16 SATURATE16(s32 a) {
	//	int __ssat(int val, unsigned int sat)
#ifdef CORTEX
	int tmp;
	asm ("ssat %0, %1, %2" : "=r" (tmp) : "I" (16), "r" (a) );
	return tmp;
#else
	if (a<-32768) a=-32768;
	else if (a>32767) a=32767;
	return a;
#endif
}

s16 LINEARINTERPRV(const s16* buf, int basei, int wobpos) { // read buf[basei-wobpos>>12] basically
	basei -= wobpos >> 12;
	wobpos &= 0xfff;
	s16 a0 = buf[basei & RVMASK];
	s16 a1 = buf[(basei - 1) & RVMASK];
#ifdef CORTEX
	int32_t out;
	uint32_t a = STEREOPACK(a1, a0);
	uint32_t b = STEREOPACK(wobpos, 0x1000 - wobpos);
	asm("smuad %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
	return out >> 12;
#else
	// dual mul
	return ((a0 * (0x1000 - wobpos) + a1 * wobpos)) >> 12;
#endif
}


/**********************/
/* the chugin impl.   */
/**********************/


// declaration of chugin constructor
CK_DLL_CTOR( plinkyrev_ctor );
CK_DLL_CTOR( plinkyrev_ctor_mix );
// declaration of chugin desctructor
CK_DLL_DTOR( plinkyrev_dtor );

CK_DLL_MFUN( plinkyrev_setFade );
CK_DLL_MFUN( plinkyrev_getFade );

CK_DLL_MFUN( plinkyrev_setShim );
CK_DLL_MFUN( plinkyrev_getShim );

CK_DLL_MFUN( plinkyrev_setWobble );
CK_DLL_MFUN( plinkyrev_getWobble );

CK_DLL_MFUN( plinkyrev_setSend );
CK_DLL_MFUN( plinkyrev_getSend );

CK_DLL_MFUN( plinkyrev_setMix );
CK_DLL_MFUN( plinkyrev_getMix );

CK_DLL_SFUN( plinkyrev_getVersion );

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICKF( plinkyrev_tickf );

// this is a special offset reserved for chugin internal data
t_CKINT plinkyrev_data_offset = 0;


//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class PlinkyRev
{
public:
  // constructor
  PlinkyRev( t_CKFLOAT mix )
  {
    m_param = 0;

    reverbpos = 0;

    // k is our kontrolable parameters
    k_reverb_fade = 240;
    k_reverb_shim = 128; // not signed (0, 65536) >> 9 -> (0, 128)
    k_reverb_wob = 0.5f; // (0.0,1.0)
    k_reverbsend = 65536 / 4; // not signed (0, 65536)

    shimmerpos1 = 2000;
    shimmerpos2 = 1000;
    shimmerfade = 0;
    dshimmerfade = 32768/4096;

    aplfo = LFOINIT(1.f / 32777.f * 9.4f);
    aplfo2 = LFOINIT(1.3f / 32777.f * 3.15971f);

    // reverb mix
    m_mix = mix;

    // set reverb buffer
    buf = new s16[RVMASK+1];

    // initialize buffer
    for (int i=0; i < RVMASK+1; i++) {
      buf[i] = 0;
    }
  }

  // for chugins extending UGen
  std::array<SAMPLE, 2> tick( SAMPLE in_left, SAMPLE in_right )
  {
    // the original reverb algorithm is processing a 32-bit signed
    // int (s32) sample input, and a 16-bit signed int reverb
    // buffer. We need to convert ChucK's double-based samples to an
    // int before processing and then convert back when done.
    //
    // Reference: https://stackoverflow.com/questions/13126297/c-c-how-to-convert-from-a-signed-32bit-integer-to-a-float-and-back

    // clamp input to range [-1, 1]
    in_left = fmax(in_left, -1.0);
    in_left = fmin(in_left, 1.0);

    in_right = fmax(in_right, -1.0);
    in_right = fmin(in_right, 1.0);

    // counter += 800 * (1.0 / 44100.0);
    // double in_d = 0.0000309 * sin(counter); // hmmmmmm

    // double d_in = in;

    // scale up the [-1,1] range to full range of s32 int
    // s32 input = in * (0x7FFFFFF + 0.5);
    // s32 input = in * (INT64_MAX + 0.5);

    // in = in * 0.000109;
    s16 inptl = ((double)in_left) * 0x7FFF;
    s16 inptr = ((double)in_right) * 0x7FFF;

    // s16 inptl = (in_d) * 0x7FFF;
    // s16 inptr = (in_d) * 0x7FFF;



    // s32 input = ((double)in) * 0x7FFFFFF;
    s32 input = STEREOPACK(inptl, inptr);

    STEREOUNPACK(input);

    // s16 test_val = (input >> 8) << 8;
    // s16 test_val = inputr;
    // SAMPLE test_output = test_val / ((float) 0x7FFF);
    // return test_output;




	int i = reverbpos;
	int outl = 0, outr = 0;

	// SAMPLE test_output = outl / ((float) 0x7FFF);
	// return test_output;

	float wob = lfo_next(&aplfo) * k_reverb_wob;
	int apwobpos = FLOAT2FIXED((wob + 1.f), 12 + 6);
	wob = lfo_next(&aplfo2)  * k_reverb_wob;
	int delaywobpos = FLOAT2FIXED((wob + 1.f), 12 + 6);

    // SAMPLE test_output = outl / ((float) 0x7FFF);
    // return test_output;

#define RVDIV /2
#define CHECKACC // assert(acc>=-32768 && acc<32767);
#define AP(len) { \
		int j = (i + len RVDIV) & RVMASK; \
		s16 d = buf[j]; \
		acc -= d >> 1; \
		buf[i] = SATURATE16(acc); \
		acc = (acc >> 1) + d; \
		i = j; \
		CHECKACC \
	}
#define AP_WOBBLE(len, wobpos) { \
		int j = (i + len RVDIV) & RVMASK;\
		s16 d = LINEARINTERPRV(buf, j, wobpos); \
		acc -= d >> 1; \
		buf[i] = SATURATE16(acc); \
		acc = (acc >> 1) + d; \
		i = j; \
		CHECKACC \
	}
#define DELAY(len) { \
		int j = (i + len RVDIV) & RVMASK; \
		buf[i] = SATURATE16(acc); \
		acc = buf[j]; \
		i = j; \
		CHECKACC \
	}
#define DELAY_WOBBLE(len, wobpos) { \
		int j = (i + len RVDIV) & RVMASK; \
		buf[i] = SATURATE16(acc); \
		acc = LINEARINTERPRV(buf, j, wobpos); \
		i=j; \
		CHECKACC \
	}

	// Griesinger according to datorro does 142, 379, 107, 277 on the way in - totoal 905 (20ms)
	// then the loop does 672+excursion, delay 4453, (damp), 1800, delay 3720 - total 10,645 (241ms)
	// then decay, and feed in
	// and on the other side 908+excursion,	delay 4217, (damp), 2656, delay 3163 - total 10,944 (248 ms)

	// keith barr says:
	// I really like 2AP, delay, 2AP, delay, in a loop.
	// I try to set the delay to somewhere a bit less than the sum of the 2 preceding AP delays,
	// which are of course much longer than the initial APs(before the loop)
	// Yeah, the big loop is great; you inject input everywhere, but take it out in only two places
	// It just keeps comin� newand fresh as the thing decays away.�If you�ve got the memoryand processing!

	// lets try the 4 greisinger initial Aps, inject stereo after the first AP,

    // SAMPLE test_output = outl / ((float) 0x7FFF);
    // return test_output;

	int acc = ((s16)(input)) * k_reverbsend >> 17;
	AP(142);
	AP(379);
	acc += (input >> 16) * k_reverbsend >> 17;
	AP(107);
//	int reinject2 = acc;
	AP(277);
	int reinject = acc;
	static int fb1 = 0; // this is probably some externally controlled param
	                    // ohhh this is to allow persistence, can be replaced
	                    // with a member var. very jank damn.
	// int fb1 = 0;
	acc += fb1;
	AP_WOBBLE(672, apwobpos);
	AP(1800);
	DELAY(4453);

	if (1) {
		// shimmer - we can read from up to about 2000 samples ago

		// Brief shimmer walkthrough:
		// - We walk backwards through the reverb buffer with 2 indices: shimmerpos1 and shimmerpos2.
		//   - shimmerpos1 is the *previous* shimmer position.
		//   - shimmerpos2 is the *current* shimmer position.
		//   - Note that we add these to i (based on reverbpos), which is also walking backwards
		//     through the buffer.
		// - shimmerfade controls the crossfade between the shimmer from shimmerpos1 and shimmerpos2.
		//   - When shimmerfade == 0, shimmerpos1 (the old shimmer) is chosen.
		//   - When shimmerfade == SHIMMER_FADE_LEN - 1, shimmerpos2 (the new shimmer) is chosen.
		//   - For everything in-between, we linearly interpolate (crossfade).
		//   - When we hit the end of the fade, we reset shimmerpos2 to a random new position and set
		//     shimmerpos1 to the old shimmerpos2.
		// - dshimmerfade controls the speed at which we fade.

		#define SHIMMER_FADE_LEN 32768
		shimmerfade += dshimmerfade;

		if (shimmerfade >= SHIMMER_FADE_LEN) {
			shimmerfade -= SHIMMER_FADE_LEN;

			shimmerpos1 = shimmerpos2;
			shimmerpos2 = (rand() & 4095) + 8192;
			dshimmerfade = (rand() & 7) + 8; // somewhere between SHIMMER_FADE_LEN/2048 and SHIMMER_FADE_LEN/4096 ie 8 and 16
		}
		// printf("i:%d, shimmerpos2:%d", i, shimmerpos2);
		// L = shimmer from shimmerpos1, R = shimmer from shimmerpos2
		u32 shim1 = STEREOPACK(buf[(i + shimmerpos1) & RVMASK], buf[(i + shimmerpos2) & RVMASK]);
		u32 shim2 = STEREOPACK(buf[(i + shimmerpos1 + 1) & RVMASK], buf[(i + shimmerpos2 + 1) & RVMASK]);
		u32 shim = STEREOADDAVERAGE(shim1, shim2);

		// Fixed point crossfade:
#ifdef CORTEX
		u32 a = STEREOPACK((SHIMMER_FADE_LEN - 1) - shimmerfade, shimmerfade);
		s32 shimo;
		asm("smuad %0, %1, %2" : "=r" (shimo) : "r" (a), "r" (shim));
#else
		STEREOUNPACK(shim);
		s32 shimo = shiml * ((SHIMMER_FADE_LEN - 1) - shimmerfade) +
								shimr * shimmerfade;
#endif
		shimo >>= 15;  // Divide by SHIMMER_FADE_LEN

		// Apply user-selected shimmer amount.
		shimo *= k_reverb_shim;
		shimo >>= 8;

		// Tone down shimmer amount.
		shimo >>= 1;

		acc += shimo;
		outl = shimo;
		outr = shimo;

		// SAMPLE test_output = outl / ((float) 0x7FFF);
		// return test_output;

		shimmerpos1--;
		shimmerpos2--;
	}


	// these isn't referenced anywhere else in the codebase?
	const static float k_reverb_color = 0.95f;
	static float lpf = 0.f, dc = 0.f;
	// const float k_reverb_color = 0.95f;
	// float lpf = 0.f, dc = 0.f;

	lpf += (((acc * k_reverb_fade) >> 8) - lpf) * k_reverb_color;
	dc += (lpf - dc) * 0.005f;
	acc = (int)(lpf - dc);
	outl += acc;

	// SAMPLE test_output = outl / ((float) 0x7FFF);
	// return test_output;

	acc += reinject;
	AP_WOBBLE(908, delaywobpos);
	AP(2656);
	DELAY(3163);
	static float lpf2 = 0.f;
	// float lpf2 = 0.f;
	lpf2+= (((acc * k_reverb_fade) >> 8) - lpf2) * k_reverb_color;
	acc = (int)(lpf2);

	outr += acc;

	reverbpos = (reverbpos - 1) & RVMASK;
	fb1=(acc*k_reverb_fade)>>8;
	s32 return_val = STEREOPACK(SATURATE16(outl), SATURATE16(outr));

	// SAMPLE test_output = outl / ((float) 0x7FFF);
	// return test_output;




    // default: this passes whatever input is patched into chugin
    // s32 return_val = 0; // placeholder

    // scale the s32 value to [-1, 1]
    // SAMPLE output = return_val / (0x7FFFFFF + 0.5);
	// return_val = (return_val >> 8) << 8;
	// SAMPLE output = return_val / ((float) 0x7FFFFFF);
    // SAMPLE output = return_val / (INT64_MAX + 0.5);
	// outl = (outl >> 8) << 8;
	SAMPLE output_l = outl / ((float) 0x7FFF);
	SAMPLE output_r = outr / ((float) 0x7FFF);

	output_l = (output_l * m_mix) + (in_left * (1.f-m_mix));
	output_r = (output_r * m_mix) + (in_right * (1.f-m_mix));

	std::array<SAMPLE, 2> output;
	output[0] = output_l;
	output[1] = output_r;
	return output;
    // return  in_d;
  }

  t_CKFLOAT setFade( t_CKFLOAT fade ) {
    // clamp to 0-1
    fadef = clamp(fade, 0.0, 1.0); // needed for returning mostly

    // some weird, probably iterative param setting
    // https://github.com/plinkysynth/plinky_public/blob/main/sw/Core/Src/plinky.c#L2261C1-L2263C35
    float f = 1.f - fadef;
    f*=f;
    f*=f;
    k_reverb_fade=(int)(250*(1.f-f));

    return fadef;
  }

  t_CKFLOAT getFade() { return fadef; }

  t_CKFLOAT setShim( t_CKFLOAT shim) {
    shim = clamp(shim, 0, 1);

    k_reverb_shim = (int)(shim * 128.0);

    return shim;
  }

  t_CKFLOAT getShim() {
    return (float)k_reverb_shim / 128.f;
  }

  t_CKFLOAT setWobble( t_CKFLOAT wob) {
    k_reverb_wob = clamp(wob, 0, 1);

    return k_reverb_wob;
  }

  t_CKFLOAT getWobble() {
    return k_reverb_wob;
  }

  t_CKFLOAT setSend( t_CKFLOAT send ) {
    send = clamp(send, 0, 1);

    k_reverbsend = (int)(send * 65536);

    return send;
  }

  t_CKFLOAT getSend() {
    return (float)k_reverbsend / 65536.0;
  }

  t_CKFLOAT setMix( t_CKFLOAT mix ) {
    m_mix = clamp(mix, 0, 1);
    return m_mix;
  }

  t_CKFLOAT getMix() {
    return m_mix;
  }

  static t_CKFLOAT clamp(t_CKFLOAT x, t_CKFLOAT low, t_CKFLOAT high) {
    return std::min(std::max(x, low), high);
  }

private:
  // instance data
  t_CKFLOAT m_param;
  t_CKFLOAT m_mix;

  // Our params. All of these are static in the original
  // implementation. Presumably because the's only one global reverb
  // on the module?

  int reverbpos;

  t_CKFLOAT fadef;
  int k_reverb_fade;
  int k_reverb_shim;
  float k_reverb_wob;
  int k_reverbsend;
  int shimmerpos1;
  int shimmerpos2;
  int shimmerfade;
  int dshimmerfade;

  lfo aplfo;
  lfo aplfo2;
  // lfo aplfo = LFOINIT(1.f / 32777.f * 9.4f);
  // lfo aplfo2 = LFOINIT(1.3f / 32777.f * 3.15971f);


  // the reverb buffer
  s16* buf;

  float counter;
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( PlinkyRev )
{
  // the version string of this chugin, e.g., "v1.2.1"
  QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "1.0.0" );
  // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
  QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "Nick Shaheed" );
  // text description of this chugin; what is it? what does it do? who is it for?
  QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "This stereo reverb is a port of the Plinky synth's reverb (https://plinkysynth.com/)" );
  // (optional) URL of the homepage for this chugin
  QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
  // (optional) contact email
  QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "nshaheed@ccrma.stanford.edu" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( PlinkyRev )
{
  // generally, don't change this...
  QUERY->setname( QUERY, "PlinkyRev" );

  // ------------------------------------------------------------------------
  // begin class definition(s); will be compiled, verified,
  // and added to the chuck host type system for use
  // ------------------------------------------------------------------------
  // NOTE to create a non-UGen class, change the second argument
  // to extend a different ChucK class (e.g., "Object")
  QUERY->begin_class( QUERY, "PlinkyRev", "UGen_Stereo" );

  // register default constructor
  QUERY->add_ctor( QUERY, plinkyrev_ctor );
  // NOTE constructors can be overloaded like any other functions,
  // each overloaded constructor begins with `QUERY->add_ctor()`
  // followed by a sequence of `QUERY->add_arg()`

  QUERY->add_ctor( QUERY, plinkyrev_ctor_mix );
  QUERY->add_arg( QUERY, "float", "mix" );

  // register the destructor (probably no need to change)
  QUERY->add_dtor( QUERY, plinkyrev_dtor );

  // for UGens only: add tick function
  // NOTE a non-UGen class should remove or comment out this next line
  QUERY->add_ugen_funcf( QUERY, plinkyrev_tickf, NULL, 2, 2 );
  // NOTE: if this is to be a UGen with more than 1 channel,
  // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
  // and declare a tickf function using CK_DLL_TICKF

  // example of adding setter method
  QUERY->add_mfun( QUERY, plinkyrev_setFade, "float", "fade" );
  // example of adding argument to the above method
  QUERY->add_arg( QUERY, "float", "fade" );
  QUERY->doc_func(QUERY, "Controls the length of the decay of the reverb. [0-1].");


  // example of adding getter method
  QUERY->add_mfun( QUERY, plinkyrev_getFade, "float", "fade" );
  QUERY->doc_func(QUERY, "Controls the length of the decay of the reverb. [0-1].");

  // example of adding setter method
  QUERY->add_mfun( QUERY, plinkyrev_setShim, "float", "shim" );
  // example of adding argument to the above method
  QUERY->add_arg( QUERY, "float", "shim" );
  QUERY->doc_func(QUERY, "Amount of octave-up signal that is fed into the reverb, causing a shimmer effect. [0-1].");

  // example of adding getter method
  QUERY->add_mfun( QUERY, plinkyrev_getShim, "float", "shim" );
  QUERY->doc_func(QUERY, "Amount of octave-up signal that is fed into the reverb, causing a shimmer effect. [0-1].");

  // example of adding setter method
  QUERY->add_mfun( QUERY, plinkyrev_setWobble, "float", "wobble" );
  // example of adding argument to the above method
  QUERY->add_arg( QUERY, "float", "wobble" );
  QUERY->doc_func(QUERY, "Amount of simulated tape speed wobble, causing pitch distortions in the reverb. [0-1].");

  // example of adding getter method
  QUERY->add_mfun( QUERY, plinkyrev_getWobble, "float", "wobble" );
  QUERY->doc_func(QUERY, "Amount of simulated tape speed wobble, causing pitch distortions in the reverb. [0-1].");

  // example of adding setter method
  QUERY->add_mfun( QUERY, plinkyrev_setSend, "float", "send" );
  // example of adding argument to the above method
  QUERY->add_arg( QUERY, "float", "send" );
  QUERY->doc_func(QUERY, "Amount of the dry sound sent to the reverb unit. Turn it up for reverb! [0-1].");

  // example of adding getter method
  QUERY->add_mfun( QUERY, plinkyrev_getSend, "float", "send" );
  QUERY->doc_func(QUERY, "Amount of the dry sound sent to the reverb unit. Turn it up for reverb! [0-1].");

  // example of adding setter method
  QUERY->add_mfun( QUERY, plinkyrev_setMix, "float", "mix" );
  // example of adding argument to the above method
  QUERY->add_arg( QUERY, "float", "mix" );
  QUERY->doc_func(QUERY, "Set reverb wet/dry mix, 0 is dry, 1 is wet [0-1].");

  // example of adding getter method
  QUERY->add_mfun( QUERY, plinkyrev_getMix, "float", "mix" );
  QUERY->doc_func(QUERY, "Get reverb wet/dry mix, 0 is dry, 1 is wet [0-1].");

  QUERY->add_sfun( QUERY, plinkyrev_getVersion, "string", "version" );
  QUERY->doc_func(QUERY, "Get version of PlinkyRev chugin.");  

  // this reserves a variable in the ChucK internal class to store
  // referene to the c++ class we defined above
  plinkyrev_data_offset = QUERY->add_mvar( QUERY, "int", "@pr_data", false );

  // ------------------------------------------------------------------------
  // end the class definition
  // IMPORTANT: this MUST be called to each class definition!
  // ------------------------------------------------------------------------
  QUERY->end_class( QUERY );

  // wasn't that a breeze?
  return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR( plinkyrev_ctor )
{
  // get the offset where we'll store our internal c++ class pointer
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = 0;

  // instantiate our internal c++ class representation
  PlinkyRev * pr_obj = new PlinkyRev( 0.5 );

  // store the pointer in the ChucK object member
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = (t_CKINT)pr_obj;
}

// implementation for the default constructor
CK_DLL_CTOR( plinkyrev_ctor_mix )
{
  // get the offset where we'll store our internal c++ class pointer
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = 0;

  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // instantiate our internal c++ class representation
  PlinkyRev * pr_obj = new PlinkyRev( arg1 );

  // store the pointer in the ChucK object member
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = (t_CKINT)pr_obj;
}


// implementation for the destructor
CK_DLL_DTOR( plinkyrev_dtor )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );
  // clean up (this macro tests for NULL, deletes, and zeros out the variable)
  CK_SAFE_DELETE( pr_obj );
  // set the data field to 0
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = 0;
}


// implementation for tick function (relevant only for UGens)
CK_DLL_TICKF( plinkyrev_tickf )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT(SELF, plinkyrev_data_offset);

  for (int i = 0; i < nframes; i++) {
    SAMPLE in_left = in[i * 2 + 0];
    SAMPLE in_right = in[i * 2 + 1];
    // invoke our tick function; store in the magical out variable
    std::array<SAMPLE, 2> pluck_out = pr_obj->tick( in_left, in_right );
    out[i * 2 + 0] = pluck_out[0];
    out[i * 2 + 1] = pluck_out[1];
  }

  // yes
  return TRUE;
}


CK_DLL_MFUN( plinkyrev_setFade )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // get next argument
  // NOTE argument type must match what is specified above in CK_DLL_QUERY
  // NOTE this advances the ARGS pointer, so save in variable for re-use
  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // call setFade() and set the return value
  RETURN->v_float = pr_obj->setFade( arg1 );
}

CK_DLL_MFUN(plinkyrev_getFade)
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // call getFade() and set the return value
  RETURN->v_float = pr_obj->getFade();
}


CK_DLL_MFUN( plinkyrev_setShim )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // get next argument
  // NOTE argument type must match what is specified above in CK_DLL_QUERY
  // NOTE this advances the ARGS pointer, so save in variable for re-use
  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // call setShim() and set the return value
  RETURN->v_float = pr_obj->setShim( arg1 );
}

CK_DLL_MFUN(plinkyrev_getShim)
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // call getShim() and set the return value
  RETURN->v_float = pr_obj->getShim();
}

CK_DLL_MFUN( plinkyrev_setWobble )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // get next argument
  // NOTE argument type must match what is specified above in CK_DLL_QUERY
  // NOTE this advances the ARGS pointer, so save in variable for re-use
  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // call setWobble() and set the return value
  RETURN->v_float = pr_obj->setWobble( arg1 );
}

CK_DLL_MFUN(plinkyrev_getWobble)
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // call getWobble() and set the return value
  RETURN->v_float = pr_obj->getWobble();
}

CK_DLL_MFUN( plinkyrev_setSend )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // get next argument
  // NOTE argument type must match what is specified above in CK_DLL_QUERY
  // NOTE this advances the ARGS pointer, so save in variable for re-use
  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // call setSend() and set the return value
  RETURN->v_float = pr_obj->setSend( arg1 );
}

CK_DLL_MFUN(plinkyrev_getSend)
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // call getSend() and set the return value
  RETURN->v_float = pr_obj->getSend();
}

CK_DLL_MFUN( plinkyrev_setMix )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // get next argument
  // NOTE argument type must match what is specified above in CK_DLL_QUERY
  // NOTE this advances the ARGS pointer, so save in variable for re-use
  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // call setMix() and set the return value
  RETURN->v_float = pr_obj->setMix( arg1 );
}

CK_DLL_MFUN(plinkyrev_getMix)
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // call getMix() and set the return value
  RETURN->v_float = pr_obj->getMix();
}

CK_DLL_SFUN(plinkyrev_getVersion)
{
  RETURN->v_string = (Chuck_String*)API->object->create_string(VM, VERSION, false);
}
