//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "PlinkyRev", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (PlinkyRev.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a PlinkyRev-test.ck boilerplate ChucK program
//      to help test your chugin (see PlinkyRev-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"

// general includes
#include <iostream>
#include <stdlib.h>
#include <algorithm>
#include <limits>
#include <cstdint>
#include <math.h>


/**********************/
/* from core.h        */
/**********************/

// struct int24{
//     unsigned int data : 24;
// };

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint64_t u32;
#ifndef __cplusplus
typedef char bool;
#define true 1
#define false 0
#endif

/**********************/
/* from lfo.h         */
/**********************/
typedef struct lfo {
	float r, i, a;
} lfo;
#define LFOINIT(f) ((lfo){1.f, 0.f, (f) + (f)})
void lfo_setfreq(lfo *l, float f) {
	l->a = f + f;
}
float lfo_next(lfo *l) {
	l->r -= l->a * l->i;
	l->i += l->a * l->r;
	return l->r;
}

/**********************/
/* from audiointrin.h */
/**********************/

#define RVMASK 16383 // define len of reverb
#define FLOAT2FIXED(x,bits) ((int)((x)*(1<<(bits))))
#define STEREOUNPACK(lr) int lr##l=(s16)lr, lr##r=(s16)(lr>>16);

u32 STEREOPACK(s16 l, s16 r) {
#ifdef CORTEX
	int32_t out;
	asm ("pkhbt %0, %1, %2, lsl #16" : "=r" (out) : "r" (l), "r" (r));
	return out;
#else
	return ((u16)l)+(((u16)r)<<16);
#endif
}

u32 STEREOADDAVERAGE(u32 a, u32 b) {
#ifdef CORTEX
	int32_t out;
	asm ("shadd16 %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
	return out;
#else
	STEREOUNPACK(a);
	STEREOUNPACK(b);
	return STEREOPACK((al+bl)>>1,(ar+br)>>1);
#endif
}

s16 SATURATE16(s32 a) {
	//	int __ssat(int val, unsigned int sat)
#ifdef CORTEX
	int tmp;
	asm ("ssat %0, %1, %2" : "=r" (tmp) : "I" (16), "r" (a) );
	return tmp;
#else
	if (a<-32768) a=-32768;
	else if (a>32767) a=32767;
	return a;
#endif
}

s16 LINEARINTERPRV(const s16* buf, int basei, int wobpos) { // read buf[basei-wobpos>>12] basically
	basei -= wobpos >> 12;
	wobpos &= 0xfff;
	s16 a0 = buf[basei & RVMASK];
	s16 a1 = buf[(basei - 1) & RVMASK];
#ifdef CORTEX
	int32_t out;
	uint32_t a = STEREOPACK(a1, a0);
	uint32_t b = STEREOPACK(wobpos, 0x1000 - wobpos);
	asm("smuad %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
	return out >> 12;
#else
	// dual mul
	return ((a0 * (0x1000 - wobpos) + a1 * wobpos)) >> 12;
#endif
}



/**********************/
/* the chugin impl.   */
/**********************/


// declaration of chugin constructor
CK_DLL_CTOR( plinkyrev_ctor );
// declaration of chugin desctructor
CK_DLL_DTOR( plinkyrev_dtor );

// example of getter/setter
CK_DLL_MFUN( plinkyrev_setParam );
CK_DLL_MFUN( plinkyrev_getParam );

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK( plinkyrev_tick );

// this is a special offset reserved for chugin internal data
t_CKINT plinkyrev_data_offset = 0;


//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class PlinkyRev
{
public:
  // constructor
  PlinkyRev( t_CKFLOAT fs )
  {
    // float f = 0.3;
    // std::cout << 1.f-f << std::endl;
    
    m_param = 0;
    
    reverbpos = 0;

    // k is our kontrolable parameters

    /*
      // some weird, probably iterative param setting
      // https://github.com/plinkysynth/plinky_public/blob/main/sw/Core/Src/plinky.c#L2261C1-L2263C35
      float f=1.f-clampf(param_eval_float(P_RVTIME, any_rnd, env16, pressure16),0.f,1.f);
      /* 1- (param ranging from 0 to 1)
      f*=f; f*=f; // f^3?
      k_reverb_fade=(int)(250*(1.f-f));
     */
    k_reverb_fade = 240;
    k_reverb_shim = 128; // not signed (0, 65536) >> 9 -> (0, 128)
    k_reverb_wob = 0.5f; // (0.0,1.0)
    k_reverbsend = 0;
    // k_reverbsend = std::numeric_limits<int>::max() / 64000;
    k_reverbsend = 32768;
    k_reverbsend = 65536; // not signed (0, 65536)
    // k_reverbsend = std::numeric_limits<int>::max() / 2;
    shimmerpos1 = 2000;
    shimmerpos2 = 1000;
    shimmerfade = 0;
    // shimmerfade = 300;
    dshimmerfade = 32768/4096;

    aplfo = LFOINIT(1.f / 32777.f * 9.4f);
    aplfo2 = LFOINIT(1.3f / 32777.f * 3.15971f);

    // set reverb buffer
    buf = new s16[RVMASK+1];

    counter = 0;
  }

  // for chugins extending UGen
  SAMPLE tick( SAMPLE in )
  {

    // the original reverb algorithm is processing a 32-bit signed
    // int (s32) sample input, and a 16-bit signed int reverb
    // buffer. We need to convert ChucK's double-based samples to an
    // int before processing and then convert back when done.
    //
    // Reference: https://stackoverflow.com/questions/13126297/c-c-how-to-convert-from-a-signed-32bit-integer-to-a-float-and-back

    // clamp input to range [-1, 1]
    in = fmax(in, -1.0);
    in = fmin(in, 1.0);

    counter += 800 * (1.0 / 44100.0);
    double in_d = 0.0000309 * sin(counter); // hmmmmmm

    // double d_in = in;

    // scale up the [-1,1] range to full range of s32 int
    // s32 input = in * (0x7FFFFFF + 0.5);
    // s32 input = in * (INT64_MAX + 0.5);

    // in = in * 0.000109;
    s16 inptl = ((double)in) * 0x7FFF;
    s16 inptr = ((double)in) * 0x7FFF;

    // s16 inptl = (in_d) * 0x7FFF;
    // s16 inptr = (in_d) * 0x7FFF;

    

    // s32 input = ((double)in) * 0x7FFFFFF;
    s32 input = STEREOPACK(inptl, inptr);

    STEREOUNPACK(input);

    // s16 test_val = (input >> 8) << 8;
    // s16 test_val = inputr;
    // SAMPLE test_output = test_val / ((float) 0x7FFF);
    // return test_output;




	int i = reverbpos;
	int outl = 0, outr = 0;

	// SAMPLE test_output = outl / ((float) 0x7FFF);
	// return test_output;
	
	float wob = lfo_next(&aplfo) * k_reverb_wob;
	int apwobpos = FLOAT2FIXED((wob + 1.f), 12 + 6);
	wob = lfo_next(&aplfo2)  * k_reverb_wob;
	int delaywobpos = FLOAT2FIXED((wob + 1.f), 12 + 6);

    // SAMPLE test_output = outl / ((float) 0x7FFF);
    // return test_output;
	
#define RVDIV /2
#define CHECKACC // assert(acc>=-32768 && acc<32767);
#define AP(len) { \
		int j = (i + len RVDIV) & RVMASK; \
		s16 d = buf[j]; \
		acc -= d >> 1; \
		buf[i] = SATURATE16(acc); \
		acc = (acc >> 1) + d; \
		i = j; \
		CHECKACC \
	}
#define AP_WOBBLE(len, wobpos) { \
		int j = (i + len RVDIV) & RVMASK;\
		s16 d = LINEARINTERPRV(buf, j, wobpos); \
		acc -= d >> 1; \
		buf[i] = SATURATE16(acc); \
		acc = (acc >> 1) + d; \
		i = j; \
		CHECKACC \
	}
#define DELAY(len) { \
		int j = (i + len RVDIV) & RVMASK; \
		buf[i] = SATURATE16(acc); \
		acc = buf[j]; \
		i = j; \
		CHECKACC \
	}
#define DELAY_WOBBLE(len, wobpos) { \
		int j = (i + len RVDIV) & RVMASK; \
		buf[i] = SATURATE16(acc); \
		acc = LINEARINTERPRV(buf, j, wobpos); \
		i=j; \
		CHECKACC \
	}

	// Griesinger according to datorro does 142, 379, 107, 277 on the way in - totoal 905 (20ms)
	// then the loop does 672+excursion, delay 4453, (damp), 1800, delay 3720 - total 10,645 (241ms)
	// then decay, and feed in
	// and on the other side 908+excursion,	delay 4217, (damp), 2656, delay 3163 - total 10,944 (248 ms)

	// keith barr says:
	// I really like 2AP, delay, 2AP, delay, in a loop.
	// I try to set the delay to somewhere a bit less than the sum of the 2 preceding AP delays,
	// which are of course much longer than the initial APs(before the loop)
	// Yeah, the big loop is great; you inject input everywhere, but take it out in only two places
	// It just keeps comin� newand fresh as the thing decays away.�If you�ve got the memoryand processing!

	// lets try the 4 greisinger initial Aps, inject stereo after the first AP,

    // SAMPLE test_output = outl / ((float) 0x7FFF);
    // return test_output;	

	int acc = ((s16)(input)) * k_reverbsend >> 17;
	AP(142);
	AP(379);
	acc += (input >> 16) * k_reverbsend >> 17;
	AP(107);
//	int reinject2 = acc;
	AP(277);
	int reinject = acc;
	static int fb1 = 0; // this is probably some externally controlled param
	                    // ohhh this is to allow persistence, can be replaced
	                    // with a member var. very jank damn.
	// int fb1 = 0;
	acc += fb1;
	AP_WOBBLE(672, apwobpos);
	AP(1800);
	DELAY(4453);

	if (1) {
		// shimmer - we can read from up to about 2000 samples ago

		// Brief shimmer walkthrough:
		// - We walk backwards through the reverb buffer with 2 indices: shimmerpos1 and shimmerpos2.
		//   - shimmerpos1 is the *previous* shimmer position.
		//   - shimmerpos2 is the *current* shimmer position.
		//   - Note that we add these to i (based on reverbpos), which is also walking backwards
		//     through the buffer.
		// - shimmerfade controls the crossfade between the shimmer from shimmerpos1 and shimmerpos2.
		//   - When shimmerfade == 0, shimmerpos1 (the old shimmer) is chosen.
		//   - When shimmerfade == SHIMMER_FADE_LEN - 1, shimmerpos2 (the new shimmer) is chosen.
		//   - For everything in-between, we linearly interpolate (crossfade).
		//   - When we hit the end of the fade, we reset shimmerpos2 to a random new position and set
		//     shimmerpos1 to the old shimmerpos2.
		// - dshimmerfade controls the speed at which we fade.

		#define SHIMMER_FADE_LEN 32768
		shimmerfade += dshimmerfade;

		if (shimmerfade >= SHIMMER_FADE_LEN) {
			shimmerfade -= SHIMMER_FADE_LEN;

			shimmerpos1 = shimmerpos2;
			shimmerpos2 = (rand() & 4095) + 8192;
			dshimmerfade = (rand() & 7) + 8; // somewhere between SHIMMER_FADE_LEN/2048 and SHIMMER_FADE_LEN/4096 ie 8 and 16
		}
		// printf("i:%d, shimmerpos2:%d", i, shimmerpos2);
		// L = shimmer from shimmerpos1, R = shimmer from shimmerpos2
		u32 shim1 = STEREOPACK(buf[(i + shimmerpos1) & RVMASK], buf[(i + shimmerpos2) & RVMASK]);
		u32 shim2 = STEREOPACK(buf[(i + shimmerpos1 + 1) & RVMASK], buf[(i + shimmerpos2 + 1) & RVMASK]);
		u32 shim = STEREOADDAVERAGE(shim1, shim2);

		// Fixed point crossfade:
#ifdef CORTEX
		u32 a = STEREOPACK((SHIMMER_FADE_LEN - 1) - shimmerfade, shimmerfade);
		s32 shimo;
		asm("smuad %0, %1, %2" : "=r" (shimo) : "r" (a), "r" (shim));
#else
		STEREOUNPACK(shim);
		s32 shimo = shiml * ((SHIMMER_FADE_LEN - 1) - shimmerfade) +
								shimr * shimmerfade;
#endif
		shimo >>= 15;  // Divide by SHIMMER_FADE_LEN

		// Apply user-selected shimmer amount.
		shimo *= k_reverb_shim;
		shimo >>= 8;

		// Tone down shimmer amount.
		shimo >>= 1;

		acc += shimo;
		outl = shimo;
		outr = shimo;

		// SAMPLE test_output = outl / ((float) 0x7FFF);
		// return test_output;		

		shimmerpos1--;
		shimmerpos2--;
	}


	// these isn't referenced anywhere else in the codebase?
	const static float k_reverb_color = 0.95f;
	static float lpf = 0.f, dc = 0.f;	
	// const float k_reverb_color = 0.95f;	
	// float lpf = 0.f, dc = 0.f;
	
	lpf += (((acc * k_reverb_fade) >> 8) - lpf) * k_reverb_color;
	dc += (lpf - dc) * 0.005f;
	acc = (int)(lpf - dc);
	outl += acc;

	// SAMPLE test_output = outl / ((float) 0x7FFF);
	// return test_output;

	acc += reinject;
	AP_WOBBLE(908, delaywobpos);
	AP(2656);
	DELAY(3163);
	static float lpf2 = 0.f;
	// float lpf2 = 0.f;
	lpf2+= (((acc * k_reverb_fade) >> 8) - lpf2) * k_reverb_color;
	acc = (int)(lpf2);

	outr += acc;

	reverbpos = (reverbpos - 1) & RVMASK;
	fb1=(acc*k_reverb_fade)>>8;
	s32 return_val = STEREOPACK(SATURATE16(outl), SATURATE16(outr));

	// SAMPLE test_output = outl / ((float) 0x7FFF);
	// return test_output;	




    // default: this passes whatever input is patched into chugin
    // s32 return_val = 0; // placeholder

    // scale the s32 value to [-1, 1]
    // SAMPLE output = return_val / (0x7FFFFFF + 0.5);
	// return_val = (return_val >> 8) << 8;
	// SAMPLE output = return_val / ((float) 0x7FFFFFF);
    // SAMPLE output = return_val / (INT64_MAX + 0.5);
	// outl = (outl >> 8) << 8;
	SAMPLE output = outl / ((float) 0x7FFF);
    return output;
    // return  in_d;
  }

  // set parameter example
  t_CKFLOAT setParam( t_CKFLOAT p )
  {
    m_param = p;
    return p;
  }

  // get parameter example
  t_CKFLOAT getParam() { return m_param; }

private:
  // instance data
  t_CKFLOAT m_param;

  // Our params. All of these are static in the original
  // implementation. Presumably because the's only one global reverb
  // on the module?

  int reverbpos;

  int k_reverb_fade;
  int k_reverb_shim;
  float k_reverb_wob;
  int k_reverbsend;
  int shimmerpos1;
  int shimmerpos2;
  int shimmerfade;
  int dshimmerfade;

  lfo aplfo;
  lfo aplfo2;  
  // lfo aplfo = LFOINIT(1.f / 32777.f * 9.4f);
  // lfo aplfo2 = LFOINIT(1.3f / 32777.f * 3.15971f);


  // the reverb buffer
  s16* buf;

  float counter;
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( PlinkyRev )
{
  // the version string of this chugin, e.g., "v1.2.1"
  QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "" );
  // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
  QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "" );
  // text description of this chugin; what is it? what does it do? who is it for?
  QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "" );
  // (optional) URL of the homepage for this chugin
  QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
  // (optional) contact email
  QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( PlinkyRev )
{
  // generally, don't change this...
  QUERY->setname( QUERY, "PlinkyRev" );

  // ------------------------------------------------------------------------
  // begin class definition(s); will be compiled, verified,
  // and added to the chuck host type system for use
  // ------------------------------------------------------------------------
  // NOTE to create a non-UGen class, change the second argument
  // to extend a different ChucK class (e.g., "Object")
  QUERY->begin_class( QUERY, "PlinkyRev", "UGen" );

  // register default constructor
  QUERY->add_ctor( QUERY, plinkyrev_ctor );
  // NOTE constructors can be overloaded like any other functions,
  // each overloaded constructor begins with `QUERY->add_ctor()`
  // followed by a sequence of `QUERY->add_arg()`

  // register the destructor (probably no need to change)
  QUERY->add_dtor( QUERY, plinkyrev_dtor );

  // for UGens only: add tick function
  // NOTE a non-UGen class should remove or comment out this next line
  QUERY->add_ugen_func( QUERY, plinkyrev_tick, NULL, 1, 1 );
  // NOTE: if this is to be a UGen with more than 1 channel,
  // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
  // and declare a tickf function using CK_DLL_TICKF

  // example of adding setter method
  QUERY->add_mfun( QUERY, plinkyrev_setParam, "float", "param" );
  // example of adding argument to the above method
  QUERY->add_arg( QUERY, "float", "arg" );

  // example of adding getter method
  QUERY->add_mfun( QUERY, plinkyrev_getParam, "float", "param" );

  // this reserves a variable in the ChucK internal class to store
  // referene to the c++ class we defined above
  plinkyrev_data_offset = QUERY->add_mvar( QUERY, "int", "@pr_data", false );

  // ------------------------------------------------------------------------
  // end the class definition
  // IMPORTANT: this MUST be called to each class definition!
  // ------------------------------------------------------------------------
  QUERY->end_class( QUERY );

  // wasn't that a breeze?
  return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR( plinkyrev_ctor )
{
  // get the offset where we'll store our internal c++ class pointer
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = 0;

  // instantiate our internal c++ class representation
  PlinkyRev * pr_obj = new PlinkyRev( API->vm->srate(VM) );

  // store the pointer in the ChucK object member
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = (t_CKINT)pr_obj;
}


// implementation for the destructor
CK_DLL_DTOR( plinkyrev_dtor )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );
  // clean up (this macro tests for NULL, deletes, and zeros out the variable)
  CK_SAFE_DELETE( pr_obj );
  // set the data field to 0
  OBJ_MEMBER_INT( SELF, plinkyrev_data_offset ) = 0;
}


// implementation for tick function (relevant only for UGens)
CK_DLL_TICK( plinkyrev_tick )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT(SELF, plinkyrev_data_offset);

  // invoke our tick function; store in the magical out variable
  if( pr_obj ) *out = pr_obj->tick( in );

  // yes
  return TRUE;
}


// example implementation for setter
CK_DLL_MFUN( plinkyrev_setParam )
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // get next argument
  // NOTE argument type must match what is specified above in CK_DLL_QUERY
  // NOTE this advances the ARGS pointer, so save in variable for re-use
  t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

  // call setParam() and set the return value
  RETURN->v_float = pr_obj->setParam( arg1 );
}


// example implementation for getter
CK_DLL_MFUN(plinkyrev_getParam)
{
  // get our c++ class pointer
  PlinkyRev * pr_obj = (PlinkyRev *)OBJ_MEMBER_INT( SELF, plinkyrev_data_offset );

  // call getParam() and set the return value
  RETURN->v_float = pr_obj->getParam();
}
